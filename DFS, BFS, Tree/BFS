# 5102. [파이썬 S/W 문제해결 기본] 6일차 - 노드의 거리
from collections import deque

def bfs(S):   # 거리를 리턴
    q = deque()
    visited = [0]*(V+1)

    visited[S] = 1
    q.append(S)

    distance = 0

    while q:
        for _ in range(len(q)):   # 가는데 걸리는 시간 or 가는 거리정도
            node = q.popleft()
            if node == G:
                return distance
            for next_node in adj_list[node]:
                if visited[next_node]:
                    continue
                visited[next_node] = 1
                q.append(next_node) 
        distance += 1

T = int(input())
for tc in range(1, T+1):
    V, E = map(int, input().split())

    adj_list = [[] for _ in range(V+1)]

    for _ in range(E):
        a, b = map(int, input().split())
        adj_list[a].append(b)
        adj_list[b].append(a)
    S, G = map(int, input().split())

    answer = bfs(S)
    print(f'#{tc} {answer}')


# 1226. [S/W 문제해결 기본] 7일차 - 미로1
from collections import deque

dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

def bfs(r, c):
    q = deque()
    visited = [[0]*16 for _ in range(16)]
    
    visited[r][c] = 1
    q.append((r, c))
    
    # 큐가 빌때까지 돌아라
    while q:
        r, c = q.popleft()   # 도달이 가능한지 아닌지

        for dir in range(4):
            nr = r + dr[dir]
            nc = c + dc[dir]

            if nr < 0 or nr >= 16 or nc < 0 or nc >= 16:
                continue
            if graph[nr][nc] == 1 or visited[nr][nc]:
                continue
            if graph[nr][nc] == 3:
                return 1
            
            visited[nr][nc] = 1
            q.append((nr, nc))

    # 출구를 발견하지 못했을 때
    return 0

T = 10
for tc in range(1, T+1):
    input()
    graph = [list(map(int, input())) for _ in range(16)]
    r, c, goal_r, goal_c = -1, -1, -1, -1

    for i in range(16):
        for j in range(16):
            if graph[i][j] == 2:
                r = i
                c = j
            elif graph[i][j] == 3:
                goal_r = i
                goal_c = j

    answer = bfs(r, c)
    print(f'#{tc} {answer}')


# 백준 2667. 단지번호붙이기
from collections import deque

dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

def bfs(r, c):
    q = deque()

    visited[r][c] = 1
    q.append((r, c))

    count = 1

    while q :
        r, c = q.popleft()

        for d in range(4):
            nr = r + dr[d]
            nc = c + dc[d]

            if nr<0 or nr>=N or nc<0 or nc>=N:
                continue
            if arr[nr][nc] == 0 or visited[nr][nc]:
                continue
            visited[nr][nc] = 1
            q.append((nr, nc))
            count += 1

    return count

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
visited = [[0]*N for _ in range(N)]
ans_list = []

for i in range(N):
        for j in range(N):
            if arr[i][j] == 1 and visited[i][j] == 0:
                ans_list.append(bfs(i, j))

print(len(ans_list))
for counts in sorted(ans_list):
    print(counts)